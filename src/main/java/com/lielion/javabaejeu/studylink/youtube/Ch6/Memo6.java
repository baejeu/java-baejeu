package com.lielion.javabaejeu.studylink.youtube.Ch6;

public class Memo6 {
    public static void main(String[] args) {
        System.out.println("6장 공부");
    }
}
/*
객체지향 언어 = 프로그래밍 언어 + 객체지향개념 (규칙)
OOP Object Oriented  Programing
핵심 개념 4가지
캡슐화, 상속, 추상화, 다형성

클래스의 정의 클래스란 객체를 정의해 놓은 것?
클래스의 용도 클래스는 객체를 생성하는데 사용

   클래스     객체
 제품 설계도   제품
  Tv 설계도    Tv

객체의 구성요소 속성과 기능
객체 = 속성(변수) + 기능(메서드)

TV 속성: 크기 길이 높이 생상 볼륨 채널
   기능: 켜기 끄기 볼륨 높이기 볼륨 낮추기 채널 변경하기 등

HW -> SW
TV -> TV

ex)
class Tv {
    String color; //색깔
    boolean power; // 전원상태
    int channel; // 채널

    void power() {
        power = !power;
    }
    void channelUp(){
        channel++;
    }
    void channelDown(){
        channel--;
    }

객체와 인스턴스
객체: 모든 인스턴스를 대표하는 용어
인스턴스: 특정 클래스로부터 생성된 객체( ex) Tv인스턴스)

           인스턴스화
클래스 -------------------> 인스턴스(객체)

q. 클래스가 왜 필요한가? (설계도)
a. 객체를 생성하기 위해  (제품)
   편리 하니깐

하나의 소스파일에 여라 클래스 작성
public class가 있는 경우, 소스 파일의 이름은 반드시 public class 이름과 일치해야 한다.
ex)

Hello2.java   <- 소스파일 이름
public class Hello2 {}
       class Hello3 {}

소스파일 이름은 메인 메소드가 있는 클레스와 일치해야한다.


객체의 생성과 사용

1. 객체의 생성

클래스명 변수명;            // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명();    // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t;                    // Tv클래스 타입의 참조변수 t선언
t = new Tv();            // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장

Tv t = new Tv();         // new 라는 연산자는 객체를 생성하고 객체 주소를 저장한다.

2. 객체의 사용

t.channel = 7;              //   참조변수.멤버변수
t.channelDown();            //   참조변수.메서드

Tv t1 = new Tv();
Tv t2 = new Tv();

t2 = t1; // t1에 저장되어 있는 객체 주소를 t2에 저장 그럼 t2 객체는 사용 불가 이때 GC(가비지 컬렉터)가 자동으로 지워준다.

객체 배열

객체 베열 == 참조변수 배열

Tv tv1, tv2, tv3;   ->  Tv[] tvArr = new Tv[3];  // 길이가 3인 Tv타입의 참조변수 배열

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();v


클래스의 정의 클래스 == 데이터 + 함수
1. 설계도
2. 데이터 + 함수
3. 사용자 정의 타입

변수  ->  배열  ->    구조체    ->    클래스
       (같은 타입)  (다른 타입)       구조체 + 함수 (서로관련)


사용자 정의 타입 - 원하는 타입을 직접 만들 수 있다.

선언위치에 따른 변수의 종류

class Variables
{
    int iv;         // 인스턴스 변수 (클레스 영역)
    static int cv;  // 클래스 변수 (클레스 영역) == static 뱐수, 공유 변수

    void method()
    {
        int lv =0;  // 지역 변수  (메서드 영역)
    }
}

클레스 영역은 선언문만 가능하다. y= x+3 (x)

생성시기

지역변수 lv : 변수 선언문이 수행되었을 때 Life cycle -> 메소드 생성 부터 종료까지
인스턴스 변수 iv : 인스턴스가 생성되었을 때 Variables va = new Variables(); 이때 생성  + 참조변수가 사라지면 GC가 청소
클래스 변수 cv : 클래스가 메모리에 올라갈 때 (클레스가 필요할 때) 객체 생성 필요x

클래스 변수와 인스턴스 변수

EX) 포커 카드 속성 : 숫자, 무늬, 높이, 폭

숫자, 무늬 : 객체마다 다르게 유지되어야함. = 인스턴스 변수 (개별속성)
높이, 폭   : 객체모두 똑같이 유지 = 클래스 변수  (공통 속성)

객체 생성시 인스턴스 변수는 Heap에 정리
클레스 변수는 다른 공간에 저장
객체 생성시 iv는 계속 생성되지만 cv는 더 생성되는건 없다.

메서드란?
1. 문장들을 묶어놓은 것.
2. 값(입력)을 받아서 처리하고, 결과를 반환(출력)
3. 하나의 메서드는 한 가지 기능만 수행하도록 작성 단일책임원칙 ?

메서드 = 선언부 + 구현부

반환 타입 메서드 이름 (타입 변수명, 타입변수명, ....)  <- 선언부 매개변수(입력) 0~n개  매개변수 = 지역변수
 {
    // 메서드 호출시 수행될 코드                    <- 구현부
 }
 출력은 0~1개

return 문
메서드에서 반환 타입이 void 이면 생략가능하다. 컴파일러가 자동추가

호출 스택 (call stack) LIFO (Last In First Out?)
스택(stack): 밑이 막힌 상자. 위에 차곡차곡 쌓인다.

메서드 수행에 필요한 메모리가 제공되는 공간
메서드가 호출되면 호출스택에 메모리 할당, 종료되면 해제

main - 실행 ( main 메서드가 println 메서드 호출 맨 위의 메서드 하나만 실행 중, 나머지는 대기중)
main - 대기 -> println - 실행

쓰레드에서는 호출 스택이 1~n

기본형 매개변수 - 변수의 값을 읽기만 할 수 있다. (Read only)
참조형 매개변수 - 변수의 값을 읽고 변경할 수 있다. (Read and write)

static 메서드와 인스턴스 메서드 차이점

인스턴스 메서드
객체 생성 후, 참조변수.메서드이름()으로 호출
인스턴스 멤버(iv, im)와 관련된 작업을 하는 메서드
메서드 내에서 인스턴스 변수 iv 사용 가능

static 메서드 (클래스 메서드)    Ex) Math.random()  = 객체생성 없이 호출한다.
객체생성 없이 클래스이름.메서드이름()으로 호출
인스턴스 멤버(iv,im)과 관련없는 작업을 하는 메서드
메서드 내에서 인스턴스 변수(iv) 사용불가

이런 작용들이
같은 클래스에서 해당하는듯?

다른 클래스의 인스턴스 변수 가져오는건 문제가 없다. ㅇㅇ

변수의 초기화
지역변수 lv는 수동 초기화 해야함. (사용전 꼭)
멤버변수 iv, cv는 자동 초기화된다.

자동초기화
boolean = false , 참조형 = null, 나머지 = 0

멤버변수의 초기화
1. 명시적 초기화 =  (간단 초기화)
class Car {
    int door = 4;               // 기본형 primitive type 변수의 초기화
    Engine e = new Engine();    // 참조형 reference 변수의 초기화           1. null  2. 객체주소


2. 초기화 블럭  복잡한 초기화
인스턴스 초기화 블럭 : {}          iv
클래스 초기화 블럭: static {}      cv

3. 생성자  iv 초기화, 복잡한 초기화
7: 70~96
8: 97~103
 */




